@using StruCal.Views.Shared
@model StruCal.ViewModels.SectionPropertiesViewModel
@{
    ViewBag.Title = "Index";
}

<div class="container">
    <h2>Welcome to the Section Properties Calculator</h2>
    <br />
    <p class="text-justify">
        The calculator is able to calculte section properties such as
        area, centre of gravity, moments of inertia of the sections with any custom geometry.
        <br />The cordinates of the section should be provided as a chain of numbers separated by semicolonsas shown in the following example: <em>5.5;10;20.4;18.8;</em>.
        <br />Please note that the chain of numbers should be ended with semicolon.
    </p>
    <br />
    <div class="row">
        <div class="col-md-4">

            @using (Html.BeginForm())
            {
                @Html.AntiForgeryToken()

                <div id="inputForms">
                    @if (ViewBag.InputErrors)
                    {
                        <div class="form-group">
                            <div class="alert alert-danger" role="alert">
                                <p>The provided input data is invalid.</p>
                            </div>
                        </div>
                    }
                    <div class="form-group">
                        @Html.LabelFor(model => model.XCoordinates, new { @class = "control-label" })
                        @Html.EditorFor(model => model.XCoordinates, new { htmlAttributes = new { @class = "form-control", @placeholder = "10;20;30;" } })
                    </div>
                    <div class="form-group">
                        @Html.LabelFor(model => model.YCoordinates, new { @class = "control-label" })
                        @Html.EditorFor(model => model.YCoordinates, new { htmlAttributes = new { @class = "form-control", @placeholder = "10;20;30;" } })
                    </div>

                    <div class="form-group">
                        <input type="submit" value="Run" class="btn btn-primary" />
                    </div>
                </div>

            }
            
        </div>
        <div class="col-md-8">
            <div id="canvas">

            </div>
        </div>
    </div>
    <div class="row" id="results">
    @if (ViewBag.ShowResults)
    {
        <hr />
        <div class="col-md-4">
            @Html.DisplayFor(e => Model.BaseSystemProperties, TemplateNames.SectionPropertyTableTemplate, new { name = "Base properties" })
        </div>
        <div class="col-md-4">
            @Html.DisplayFor(e => Model.CentralSystemProperties, TemplateNames.SectionPropertyTableTemplate, new { name = "Central properties" })
        </div>
        <div class="col-md-4">
            @Html.DisplayFor(e => Model.PrincipalSystemProperties, TemplateNames.SectionPropertyTableTemplate, new { name = "Principal properties" })
        </div>   
            @*<table style="width:auto" class="table table-bordered">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th></th>
                        <th>Value</th>
                    </tr>
                </thead>
                @foreach (var item in Model.BaseSystemProperties)
                {
                    <tr>
                        <td>@Html.DisplayFor(e => item.Name) </td>
                        <td>
                            <a data-toggle="tooltip" data-placement="bottom" title="@item.Description">
                                <span class="glyphicon glyphicon-info-sign"></span>
                            </a>
                        </td>
                        <td>@Html.DisplayFor(e => item.Value)</td>
                    </tr>
                }

            </table>*@
    }
    </div>
</div>
@*<script src="~/Scripts/jquery-1.10.2.min.js"></script>*@
<script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/2.3.6/svg.min.js"></script>
@Scripts.Render("~/bundles/jquery")
<script>
    $(document).ready(function () {

        createDrawing();
        $("#inputForms input").change(createDrawing);
        $("#inputForms input").keyup(createDrawing);
        $(window).resize(createDrawing);
        function createDrawing() {
            var canvasObject = $('#canvas');
            var xString = $("#XCoordinates").val();
            var yString = $("#YCoordinates").val();

            var x = splitCoordinates(xString);
            var y = splitCoordinates(yString);

            if (x.length != y.length) {
                return;
            }

            fillCanvas(x, y, 'canvas');
        }
    });





    //---SHOULD BE PUT TO SEPARATE FILE--//

    //main function for filling canvas with objects: section, vertical and horizontal lines,
    //axes of coordinate system
    function fillCanvas(xCoordinates, yCoordinates, canvasParentId) {
        var canvasObject = $('#' + canvasParentId);
        canvasObject.empty();

        var canvasWidth = canvasObject.width();
        var canvasHeight = canvasWidth * 0.5;
        canvasObject.height(canvasHeight);

        var drawing = SVG('canvas').size(canvasWidth, canvasHeight);

        //drawVerticalLines(drawing, canvasWidth, canvasHeight);
        //drawHorizontalLines(drawing, canvasWidth, canvasHeight);
        drawBackgroundPattern(drawing, canvasWidth, canvasHeight);

        drawSection(drawing, xCoordinates, yCoordinates, canvasObject);

    }

    //drawing functions. Coordinates are provides as array
    function drawSection(drawing, xCoordinates, yCoordinates, canvasObject) {

        var maxX = getMaxValue(xCoordinates);
        var minX = getMinValue(xCoordinates);
        var maxY = getMaxValue(yCoordinates);
        var minY = getMinValue(yCoordinates);
        var sectionWidth = getSectionDimension(maxX, minX);
        var sectionHeight = getSectionDimension(maxY, minY);

        //var sectionCentreX = ((maxX - minX) / 2)+minX;
        //var sectionCentreY = ((maxY - minY) / 2)+minY;
        var sectionCentreX = getSectionCentre(minX, maxX);
        var sectionCentreY = getSectionCentre(minY, maxY);

        console.log('centers: '+sectionCentreX + '   ' + sectionCentreY);

        var canvasWidth = canvasObject.width();
        var canvasHeight = canvasObject.height();

        var scale = getDrawingScale(canvasWidth, canvasHeight, sectionWidth, sectionHeight);
        //convert coordinates to canvas
        var transferedX = [];
        var transferedY = [];
        for (i = 0; i < xCoordinates.length ; i++) {
            transferedX[i] = transferXToCanvasSystem(xCoordinates[i], sectionCentreX, scale, canvasWidth);
            transferedY[i] = transferYToCanvasSystem(yCoordinates[i], sectionCentreY, scale, canvasHeight);

            //console.log(String(transferedX[i]) + " " + String(transferedY[i]));
        }

        var chainCoordinates = transferCoordinatesToPlot(transferedX, transferedY);
        console.log('chaincoordinates:' + chainCoordinates);
        var polygon = drawing.polygon(chainCoordinates).fill({ color: '#3276b1', opacity: 0.9 }).stroke({ width: 3, color: '#054072' });
    }

    function drawBackgroundPattern(drawing, width, height)
    {
        //drawVerticalLines(drawing, width, height);
        //drawHorizontalLines(drawing, width, height);

        var patternSize = 20;

        //canvas width and height are rouned such way that they are multiplier of patternSize

        var correctedWidth = Math.floor(width / patternSize) * patternSize;
        var correctedHeight = Math.floor(height / patternSize) * patternSize;


        //var pattern = drawing.pattern(patternSize, patternSize, function (add) {
        //    add.line(0, 0, patternSize, 0).stroke({ width: 1, color: 'grey' });
        //    add.line(0, 0, 0, patternSize).stroke({ width: 1, color: 'grey' });
        //});
        var patternCentre = patternSize / 2;
        var pattern = drawing.pattern(patternSize, patternSize, function (add) {
            add.line(0, patternCentre, patternSize, patternCentre).stroke({ width: 1, color: 'LightGrey' });
            add.line(patternCentre, 0, patternCentre, patternSize).stroke({ width: 1, color: 'LightGrey' });
        });
        var rectangle = drawing.rect(correctedWidth, correctedHeight).fill(pattern);
        //bottom and right line
        //var bottomLine = drawing.rect(correctedWidth, correctedHeight).stroke({ width: 1, color: 'grey' }).fill('none').move(2,2);

    }
    function drawVerticalLines(drawing, width, height) {
        var numberOfLines = 10;
        var distance = width / numberOfLines;

        for (i = 0; i <= numberOfLines; i++) {
            var x1 = 0 + i * distance;
            var x2 = x1;
            var y1 = 0;
            var y2 = height;

            console.log(x1);
            var input = convertCoordinatesToLineInput(x1, y1, x2, y2);
            console.log(input);
            var line = drawing.line(input).stroke({ width: 1, color: 'Gray' });
        }
    }
    function drawHorizontalLines(drawing, width, height) {
        var numberOfLines = 10;
        var distance = height / numberOfLines;

        for (i = 0; i <= numberOfLines; i++) {
            var x1 = 0;
            var x2 = width;
            var y1 = 0 + i * distance;
            var y2 = 0 + i * distance;

            console.log(x1);
            var input = convertCoordinatesToLineInput(x1, y1, x2, y2);
            console.log(input);
            var line = drawing.line(input).stroke({ width: 1, color: 'Gray' });
        }
    }

    function convertCoordinatesToLineInput(x1, y1, x2, y2) {
        var result = x1.toString() + ',' + y1.toString() + ' ' + x2.toString() + ',' + y2.toString();
        return result;
    }

    //transfers arrays of x and y coordinates to the following string
    function transferCoordinatesToPlot(xCoordinates, yCoordinates) {
        var coordinates = "";
        for (i = 0; i < xCoordinates.length; i++) {
            var x = xCoordinates[i].toString();
            var y = yCoordinates[i].toString();
            //console.log(x + " " + y);
            var insert = x + "," + y;
            coordinates = coordinates + insert + " ";
        }

        return coordinates;
    }

    function transferXToCanvasSystem(pointX, centreX, scale, canvasWidth) {
        
        var x = ((pointX - centreX) * scale) + canvasWidth / 2;
        console.log('poinX:' + pointX + ' centreX:' + centreX + ' scale:' + scale + ' canvasWidth:' + canvasWidth + ' x:' + x);
        return x;
    }

    function transferYToCanvasSystem(pointY, centreY, scale, canvasHeight) {
        var y = (-(pointY - centreY) * scale) + canvasHeight / 2;
        return y;
    }

    function getMaxValue(array) {
        return Math.max.apply(null, array);
    }

    function getMinValue(array) {
        return Math.min.apply(null, array);
    }

    function getSectionCentre(minCoordinate,maxCoordinate)
    {
        return ((maxCoordinate - minCoordinate) / 2) + minCoordinate;
    }

    function getSectionDimension(maxCoordinates, minCoordinates) {
        var dimension = maxCoordinates - minCoordinates;
        return dimension;
    }

    function getDrawingScale(canvasWidth, canvasHeight, sectionWidth, sectionHeight) {
        var factor = 2;

        var scale1 = canvasHeight / sectionHeight / factor;
        var scale2 = canvasWidth / sectionWidth / factor;

        var scale = Math.min(scale1, scale2);
        return scale;
    }

    function splitCoordinates(coordinates) {
        var splitedCoordinates = coordinates.split(";");
        return splitedCoordinates
    }

</script>
